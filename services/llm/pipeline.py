"""Adaptive LLM orchestration with pluggable prompt templates."""

from __future__ import annotations

import random
from dataclasses import dataclass
from typing import Dict, Iterable, List

from services.ingestion.schemas import Choice, Question


@dataclass
class UserAnswer:
    question_id: str
    answer: str
    is_correct: bool


class AdaptiveLLMPipeline:
    def __init__(self, provider: str = "offline") -> None:
        self.provider = provider

    def classify_difficulty(self, question: Question) -> str:
        length = len(question.body)
        if length < 140:
            return "easy"
        if length < 280:
            return "medium"
        return "hard"

    def generate_followup(self, question: Question, target_difficulty: str) -> Question:
        labels = ["A", "B", "C", "D"]
        choices = [Choice(label=label, body=f"Auto-generated distractor {idx}") for idx, label in enumerate(labels, start=1)]
        return Question(
            body=f"Follow-up ({target_difficulty}) derived from: {question.body[:80]}",
            choices=choices,
            solution="A",
            explanation="Generated by offline pipeline",
            metadata=question.metadata,
        )

    def build_mock_test(self, question_pool: Iterable[Question], blueprint: Dict[str, int]) -> List[Question]:
        categorized: Dict[str, List[Question]] = {"easy": [], "medium": [], "hard": []}
        for question in question_pool:
            diff = self.classify_difficulty(question)
            categorized[diff].append(question)

        mock_test: List[Question] = []
        for difficulty, count in blueprint.items():
            pool = categorized.get(difficulty, [])
            mock_test.extend(pool[:count])
        return mock_test

    def remediation_questions(self, user_answers: Iterable[UserAnswer], question_lookup: Dict[str, Question]) -> List[Question]:
        weak_questions = [qa for qa in user_answers if not qa.is_correct]
        result = []
        for qa in weak_questions:
            original = question_lookup[qa.question_id]
            target = self.classify_difficulty(original)
            result.append(self.generate_followup(original, target))
        return result
